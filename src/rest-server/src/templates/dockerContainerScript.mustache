#!/bin/bash

# Copyright (c) Microsoft Corporation
# All rights reserved.
#
# MIT License
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the "Software"), to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
# to permit persons to whom the Software is furnished to do so, subject to the following conditions:
# The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
# BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


# Bootstrap script for docker container.

exec 17>/pai/log/DockerContainerDebug.log
BASH_XTRACEFD=17

function exit_handler_basic()
{
  printf "%s %s\n" \
    "[DEBUG]" "Docker container exit handler: EXIT signal received in docker container, exiting ..."
}

# The cleaner will send SIGUSR1(10) to container to kill it. Trap the signal here and exit with code 1.
function out_of_disk_kill_handler()
{
  printf "%s %s\n" \
    "[INFO]" "Docker container killed by cleaner due to disk pressure."
  exit 1
}

set -x
PS4="+[\t] "
trap exit_handler_basic EXIT
trap out_of_disk_kill_handler USR1

touch "/alive/docker_$PAI_CONTAINER_ID"


export PAI_WORK_DIR="$(pwd)"
PAI_WEB_HDFS_PREFIX={{ webHdfsUri }}/webhdfs/v1/Container

# Make all GPUs allocated to the container accessible
export NVIDIA_VISIBLE_DEVICES=all
export PAI_OOM_KILLED_SIGNAL="${PAI_OOM_KILLED_SIGNAL:-INT}"

export PAI_GRACEFUL_EXIT_SIGNAL="${PAI_GRACEFUL_EXIT_SIGNAL:-TERM}"
export PAI_GRACEFUL_EXIT_TIMEOUT="${PAI_GRACEFUL_EXIT_TIMEOUT:-30}"

task_role_no={{ idx }}

printf "%s %s\n%s\n\n" "[INFO]" "ENV" "$(printenv | sort)"

# Write env to system-wide environment
env | grep -E "^PAI|PATH|PREFIX|JAVA|HADOOP|NVIDIA|CUDA|(.*_PROXY)" > /etc/environment

cp -r /pai/code/* ./

function webhdfs_create_file()
{
  webHdfsRequestPath=${1}"?user.name="{{ jobData.userName }}"&op=CREATE"
  redirectResponse=$(curl -i -X PUT ${webHdfsRequestPath} -o /dev/null -w %{redirect_url}' '%{http_code})
  redirectCode=$(cut -d ' ' -f 2 <<< ${redirectResponse})
  if [[ ${redirectCode} = "307" ]]; then
    redirectUri=$(cut -d ' ' -f 1 <<< ${redirectResponse})
    createResponse=$(curl -i -S -X PUT ${redirectUri})
  else
    printf "%s %s\n %s %s\n %s %s\n" \
      "[WARNING]" "Webhdfs creates folder failed" \
      "Folder Path:" ${webHdfsRequestPath} \
      "Response code:" ${redirectCode}
  fi
}

function webhdfs_download_file()
{
  webHdfsRequestPath=${1}"?user.name="{{ jobData.userName }}"&op=OPEN"
  localPath=${2}
  downloadResponse=$(curl -S -L ${webHdfsRequestPath} -o ${localPath} -w %{http_code})
  if [[ ${downloadResponse} = "200" ]]; then
    printf "%s %s\n" \
      "[INFO]" "Webhdfs downloads file succeed"
  else
    printf "%s %s\n" \
      "[WARNING]" "Webhdfs downloads file failed"
  fi
}

function prepare_ssh()
{
  mkdir /root/.ssh
  sed -i 's/PermitRootLogin prohibit-password/PermitRootLogin yes/' /etc/ssh/sshd_config
  sed 's@session\s*required\s*pam_loginuid.so@session optional pam_loginuid.so@g' -i /etc/pam.d/sshd
}

function start_ssh_service()
{
  printf "%s %s\n" \
    "[INFO]" "start ssh service"
  cat /root/.ssh/{{ jobData.jobName }}.pub >> /root/.ssh/authorized_keys
  sed -i 's/Port.*/Port '$PAI_CONTAINER_SSH_PORT'/' /etc/ssh/sshd_config
  echo "sshd:ALL" >> /etc/hosts.allow
  service ssh restart
}

function get_ssh_key_files()
{
  info_source="webhdfs"
  localKeyPath=/root/.ssh/{{ jobData.jobName }}.pub
  localPrivateKeyPath=/root/.ssh/{{ jobData.jobName }}

  if [[ -f $localKeyPath ]]; then
    rm -f $localKeyPath
  fi

  if [[ "$info_source" = "webhdfs" ]]; then
    webHdfsKeyPath=${PAI_WEB_HDFS_PREFIX}/{{ jobData.userName }}/{{ jobData.jobName }}/ssh/keyFiles/{{ jobData.jobName }}.pub
    webhdfs_download_file $webHdfsKeyPath $localKeyPath
    webHdfsPrivateKeyPath=${PAI_WEB_HDFS_PREFIX}/{{ jobData.userName }}/{{ jobData.jobName }}/ssh/keyFiles/{{ jobData.jobName }}
    webhdfs_download_file $webHdfsPrivateKeyPath $localPrivateKeyPath
    chmod 400 ${localPrivateKeyPath}
  else
    printf "%s %s\n" \
      "[WARNING]" "Get another key store way"
  fi
}

function generate_ssh_connect_info()
{
  info_source="webhdfs"
  destFileName=${1}

  if [[ "$info_source" = "webhdfs" ]]; then
    webHdfsRequestPath=$destFileName
    webhdfs_create_file $webHdfsRequestPath
  else
    printf "%s %s\n" \
      "[WARNING]" "Get another key store way"
  fi
}

# Check is SSH exists, if not - ignore ssh preparation and start part
# Start sshd in docker container
if service --status-all 2>&1 | grep -q ssh; then
  prepare_ssh
  get_ssh_key_files
  sshConnectInfoFolder=${PAI_WEB_HDFS_PREFIX}/${PAI_USER_NAME}/${PAI_JOB_NAME}/ssh/$APP_ID
  # Generate ssh connect info file in "PAI_CONTAINER_ID-PAI_CURRENT_CONTAINER_IP-PAI_CONTAINER_SSH_PORT" format on hdfs
  destFilePath=${sshConnectInfoFolder}/$PAI_CONTAINER_ID-$PAI_CONTAINER_HOST_IP-$PAI_CONTAINER_SSH_PORT
  generate_ssh_connect_info ${destFilePath}

  # Enable SSH connect
  cp /pai/ssh_config/config /root/.ssh/
  start_ssh_service
else
  printf "%s %s\n %s %s \n" \
    "[WARNING]" "Open-ssh server not found, will not enable ssh service." \
    "[INFO]" "Please refer to PAI dockerfile example to get ssh service enabled. https://github.com/Microsoft/pai/tree/master/examples/Dockerfiles"
fi

{{# reqAzRDMA }}
{{# azRDMA }}
function azure_rdma_preparation()
{
    # https://unix.stackexchange.com/questions/404189/find-and-sed-string-in-docker-got-error-device-or-resource-busy
    cp /etc/hosts /hosts.tmp

    sed -i "/127.0.0.1/c\127.0.0.1 localhost" /hosts.tmp
{{# paiMachineList }}
    echo {{hostip}} {{hostname}} >> /hosts.tmp
{{/ paiMachineList }}
    cat /hosts.tmp > /etc/hosts
}

azure_rdma_preparation
{{/ azRDMA }}
{{/ reqAzRDMA }}

function set_up_user()
{
  PAI_CONTAINER_USER_NAME="${PAI_CONTAINER_USER_NAME:-$PAI_USER_NAME}"
  PAI_CONTAINER_USER_NAME="${PAI_CONTAINER_USER_NAME:-root}" # fallback
  PAI_CONTAINER_USER_UID="${PAI_CONTAINER_USER_UID:-$PAI_USER_UID}"
  PAI_CONTAINER_USER_GID="${PAI_CONTAINER_USER_GID:-$PAI_USER_GID}"
  PAI_CONTAINER_USER_GROUPS="${PAI_CONTAINER_USER_GROUPS:-$PAI_USER_GROUPS}"

  if [[ "${PAI_CONTAINER_USER_NAME}" = "root" ]]; then
    printf "%s %s\n" \
      "[INFO]" "Running as user '${PAI_CONTAINER_USER_NAME}'"
    return
  fi

  if [[ -n "${PAI_CONTAINER_USER_NAME}" ]]; then
    for gid in ${PAI_CONTAINER_USER_GID} ${PAI_CONTAINER_USER_GROUPS}; do
      groupadd -g "${gid}" "${gid}"
    done

    if [[ -n "${PAI_CONTAINER_USER_UID}" ]]; then
      local userid="-u ${PAI_CONTAINER_USER_UID}"
    fi
    if [[ -n "${PAI_CONTAINER_USER_GID}" ]]; then
      local usergid="-g ${PAI_CONTAINER_USER_GID}"
    fi
    if [[ -n "${PAI_CONTAINER_USER_GROUPS}" ]]; then
      local usergroups="-G $(echo "${PAI_CONTAINER_USER_GROUPS}" | sed "s@ @,@g" -)"
    fi

    # avoid Docker sparse files problem: https://github.com/moby/moby/issues/5419
    useradd $userid $usergid $usergroups \
      --create-home --home-dir "/home/${PAI_CONTAINER_USER_NAME}" \
      --no-log-init \
      --shell /bin/bash --password "" \
      "${PAI_CONTAINER_USER_NAME}"
    if [[ "$?" -ne "0" ]]; then
      printf "%s %s\n" \
        "[ERROR]" "Failed to create the requested user"
      return
    fi

    # Enable passwordless login via SSH
    cp -r /root/.ssh /home/${PAI_CONTAINER_USER_NAME}/

    # Enable sudo invocation if possible
    if sudo -V >/dev/null 2>&1; then
      echo "${PAI_CONTAINER_USER_NAME} ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers
    else
      printf "%s %s\n" \
        "[WARNING]" "Failed to find sudo, root access will be unavailable"
    fi
  fi
}

set_up_user


function write_user_command()
{
  PAI_USER_COMMAND_DIR="/pai/taskData"
  PAI_USER_COMMAND_PATH="${PAI_USER_COMMAND_DIR}/command.sh"
  mkdir -p "${PAI_USER_COMMAND_DIR}"

  # Read an escaped string to an array and unescape
  local lines=$'{{ taskData.command }}'
  readarray -n 50 -t lines <<< "${lines}"
  read -n 1000 -a lines <<< "${lines[@]}"

  echo "#!/bin/bash" > "${PAI_USER_COMMAND_PATH}"

  # By default, exit on the first error
  echo 'set -e' >> "${PAI_USER_COMMAND_PATH}"

  # Sending a signal to Bash makes it to exit *immediately*,
  # if the signal has the default (trap - SIG) handler
  # (as opposed to non-default handlers,
  # which wait for the current command to finish),
  # so the signal should be catched in the user command script.
  #
  # By default, user command script does nothing on the signals PAI sends.
  #
  # We could leave the handlers empty ("") or set the default (- or nothing)
  # handlers, however, doing this incurs an issue in a subprocess
  # (e.g. if user command runs a script) -
  # it can not change the default handler to anything else (reference below).
  # Thus, we have to set any non-empty (not "") handler. This way it works.
  #
  # References:
  # > POSIX 2 / https://www.gnu.org/software/bash/manual/html_node/Bourne-Shell-Builtins.html:
  # > Signals ignored upon entry to the shell cannot be trapped or reset.
  # > Trapped signals that are not being ignored are reset to their original
  # >   values in a subshell or subshell environment when one is created.
  #
  echo "trap ' ' ${PAI_GRACEFUL_EXIT_SIGNAL}" >> "${PAI_USER_COMMAND_PATH}"
  echo "trap ' ' ${PAI_OOM_KILLED_SIGNAL}" >> "${PAI_USER_COMMAND_PATH}"

  # Enable logging for the user command
  echo 'set -x' >> "${PAI_USER_COMMAND_PATH}"

  printf '%s\n' "${lines[@]}" >> "${PAI_USER_COMMAND_PATH}"

  chmod a+x "${PAI_USER_COMMAND_PATH}"
}

function run_user_command()
{
  printf "%s %s\n\n" "[INFO]" "USER COMMAND START"
  su "${PAI_CONTAINER_USER_NAME}" "${PAI_USER_COMMAND_PATH}" || exit $?
  printf "\n%s %s\n\n" "[INFO]" "USER COMMAND END" # job_exporter relay on this exact output, if you are going to change this, remember to change job_exporter also
  exit 0
}

write_user_command
run_user_command &
user_command_pid=$!


container_id=$(cat /proc/self/cgroup | grep "memory" | awk -F '/' '{print $NF}')

function check_oom_killer()
{
  container_id="$1"
  [ -e "$container_id" ] && return 1
  dmesg | grep -i kill | grep "/docker/$container_id" | tail -n 1 | sed -r "s@\\[(.*)\\.(.*)\\].*@\\1\\2@g" -
}

function notify_user_command()
{
  local signal="${1-INT}"

  # We have to send the signal to all the user command children.
  # However, the 'su' command should not be signaled as it will forward
  # the signal, but also finish the execution, while the user command
  # may not expect this. Instead, we signal the user command directly.
  # The user command, executed with 'su', obtains a new session
  # and a process group. So, to notify all the child processes
  # we can send the signal to the group.
  #
  # WARNING: when changing this, check the run_user_command() implementation.
  #
  local pid=$user_command_pid # for bash subprocess
  local pid="$(ps --ppid $pid -o pid h | tr -d ' ')" # for su command
  local pid="$(ps --ppid $pid -o pid h | tr -d ' ')" # for su command child
  local pid="$(ps -p $pid -o pgid h | tr -d ' ')" # get process group id
  if [[ -n "$signal" && -n "$pid" ]]; then
    kill -"$signal" -"$pid"
  fi
}

is_exiting=0
function exit_gracefully()
{
  if [ "1" == "$is_exiting" ] || \
       ! kill -0 $user_command_pid 2>/dev/null; then
    return
  fi

  is_exiting=1

  notify_user_command "${PAI_GRACEFUL_EXIT_SIGNAL}" 2>/dev/null

  local timeout="${PAI_GRACEFUL_EXIT_TIMEOUT:-30}"
  local start_time=$(date +%s)
  while [ $(( $(date +%s) - $start_time )) -lt $timeout ] && \
          kill -0 $user_command_pid 2>/dev/null; do
    sleep 5
  done

  if kill -0 $user_command_pid 2>/dev/null; then
    notify_user_command KILL 2>/dev/null
  fi
}

function term_handler()
{
  echo "[DEBUG] Docker container has catched TERM signal. Finishing the work..."
  exit_gracefully
}

function exit_handler_extended()
{
  exit_gracefully
  exit_handler_basic
}

trap term_handler TERM
trap exit_handler_extended EXIT


last_oom_killed=$(check_oom_killer "$container_id")
last_oom_killed=${last_oom_killed:-0}

while [ $(( $(date +%s) - $(stat -c %Y /alive/yarn_$PAI_CONTAINER_ID) )) -lt 30 ] && \
      [ "1" != "$is_exiting" ] && \
        kill -0 $user_command_pid 2>/dev/null; do
  sleep 20

  current_oom_killed=$(check_oom_killer "$container_id")
  current_oom_killed=${current_oom_killed:-0}
  if [ "$current_oom_killed" -gt "$last_oom_killed" ]; then
    last_oom_killed=$current_oom_killed
    echo "[WARNING]" "One of the child processes has been killed by the OOM killer." \
      "Notifying the others with the '${PAI_OOM_KILLED_SIGNAL}' signal"
    # User can ignore these failures if they are expected,
    # thus we should not fail immediately or expect the user code to fail.
    notify_user_command "${PAI_OOM_KILLED_SIGNAL}" 2>/dev/null
  fi
done

if kill -0 $user_command_pid 2>/dev/null; then
  echo "[INFO] The job has been killed, Docker container exiting"
  exit 0
else
  if [ "$last_oom_killed" -gt "0" ]; then
    echo "[WARNING]" "During the work there were some out-of-memory conditions." \
      "Check the task logs for additional info."
  fi

  wait $user_command_pid
  user_command_exitcode=$?

{{# isDebug }}
  if [[ $user_command_exitcode -ne 0 && "0" == "$is_exiting" ]]; then
    echo "============================================================================="
    echo "======   The job container failed, so it will be reserved for a while  ======"
    echo "======          After debugging, please stop the job manually.         ======"
    echo "============================================================================="

    sleep_time={{ debuggingReservationSeconds }}
    sleep_count=0

    while [ $(( $(date +%s) - $(stat -c %Y /alive/yarn_$PAI_CONTAINER_ID) )) -lt 30 ] && \
        [ "$sleep_count" -lt "$sleep_time" ]; do
        sleep 20
        sleep_count=$((sleep_count+20))
    done

  fi
{{/ isDebug }}

  echo "[INFO] The job has finished with exit code $user_command_exitcode"
  exit $user_command_exitcode
fi

